server {
    # Listen on port 443, the standard port for HTTPS traffic.
    # The 'ssl' directive enables SSL/TLS.
    listen 443 ssl;
    listen [::]:443 ssl;

    # This can be left as an underscore to accept requests for any hostname,
    # which is fine for this internal-only setup.
    server_name _;

    # These lines point Nginx to the certificate and private key you just created.
    # The paths are inside the Docker container, which we will set up in the next step.
    ssl_certificate /etc/nginx/certs/fullchain.pem;
    ssl_certificate_key /etc/nginx/certs/privkey.pem;

    # Specify modern, secure SSL/TLS protocols.
    ssl_protocols TLSv1.2 TLSv1.3;
    
    client_max_body_size 100M;

    # This is the core logic. All incoming requests to the root path '/' are handled here.
    location / {
        # This is the magic part. 'proxy_pass' forwards the request.
        # 'http://api:8000' tells Nginx to send the request to the service named 'api'
        # (from our docker-compose file) on its port 8000. Docker's internal networking
        # will automatically resolve 'api' to the correct container's IP address.
        proxy_pass http://api:8000;

        # --- ADDED THESE THREE LINES ---
        proxy_connect_timeout 600;
        proxy_send_timeout 600;
        proxy_read_timeout 600;
        # ---------------------------

        # These headers are important for passing information about the original
        # request to your Python API, which can be useful for logging or logic.
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}